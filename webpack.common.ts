import path from 'path';
import { fileURLToPath } from 'url';
import { GenerateSW } from 'workbox-webpack-plugin';
import webpack from 'webpack';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class FileListPlugin {
  apply(compiler) {
    // Hook into the 'emit' stage of the compilation process.
    // This hook is asynchronous, so 'tapAsync' is used.
    compiler.hooks.emit.tapAsync('FileListPlugin', (compilation, callback) => {
      // Define the structure and types for the 'manifestData' object.
      // This object will store a list of all filenames and specific details for CSS and JS files.
      const manifestData: {
        files: string[]; // An array to hold all asset filenames.
        css?: { filename: string; hash: string }; // Optional: details for the main CSS file.
        js?: { filename: string; hash: string }; // Optional: details for the main JS file.
      } = { files: [] }; // Initialize with 'files' as an empty array of strings.

      // Iterate over all assets generated by the Webpack compilation.
      // 'compilation.assets' is an object where keys are filenames.
      for (const filename in compilation.assets) {
        // Add the current filename to the 'files' array.
        // Since 'manifestData.files' is now explicitly typed as 'string[]',
        // pushing a 'string' (filename) is allowed.
        manifestData.files.push(filename);

        // Split the filename by '.' to extract its parts.
        // For example, 'app.bundle.min.js' becomes ['app', 'bundle', 'min', 'js'].
        const filenameParts = filename.split('.');
        // The last part is assumed to be the file extension (e.g., 'js', 'css').
        const filetype = filenameParts[filenameParts.length - 1];

        // Check if the filetype is either 'css' or 'js'.
        if (filetype === 'css' || filetype === 'js') {
          // The second to last part of the filename is assumed to be the content hash.
          // This relies on a naming convention like '[name].[hash].[ext]'.
          // For example, in 'main.abcdef123.js', 'abcdef123' is the hash.
          // If there's no hash (e.g. 'main.js'), this might grab the name part.
          // Ensure your filename structure matches this assumption.
          const hash =
            filenameParts.length > 1
              ? filenameParts[filenameParts.length - 2]
              : '';

          // Store the filename and extracted hash for this specific filetype.
          // This overwrites if multiple CSS or JS files are found;
          // it effectively stores the *last* processed CSS or JS file's details.
          if (filetype === 'css') {
            manifestData.css = {
              filename,
              hash,
            };
          } else if (filetype === 'js') {
            manifestData.js = {
              filename,
              hash,
            };
          }
        }
      }

      // Convert the 'manifestData' object into a JSON string.
      const manifestJsonString = JSON.stringify(manifestData, null, 2); // Added null, 2 for pretty printing

      // Add a new asset to the compilation output, named 'filelist.json'.
      // This file will contain the JSON string created above.
      compilation.assets['filelist.json'] = {
        // The source() method must return the content of the asset.
        source: () => manifestJsonString,
        // The size() method must return the size of the asset content in bytes.
        size: () => manifestJsonString.length,
      };

      // Call the callback to signal that this asynchronous operation is complete.
      callback();
    });
  }
}

export default {
  target: 'webworker',
  entry: {
    main: path.join(__dirname, 'assets/js', 'service-worker.js'),
  },
  devtool: 'source-map',
  performance: {
    maxEntrypointSize: 100000,
    maxAssetSize: 500000,
    hints: 'warning',
  },
  plugins: [
    new FileListPlugin(),
    new GenerateSW({
      clientsClaim: true,
      skipWaiting: true,
    }),
  ],
};
