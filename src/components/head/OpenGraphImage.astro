---
/**
 * Dynamic OG image generation for blog posts.
 *
 * - Uses satori to render SVG from JSX/HTML markup.
 * - Uses resvg to convert SVG to PNG.
 * - Caches generated PNG images on disk for performance.
 *
 * Route: /blog/[year]/[slug]/og.png
 * Collection id format: [year]/[slug]
 *
 * Query params:
 *   - width:  number (default 1200)
 *   - height: number (default 630)
 *
 * @see https://github.com/vercel/satori
 * @see https://www.npmjs.com/package/satori-html
 * @see https://og-playground.vercel.app/ (Satori playground)
 *
 * Satori supports TailwindCSS via `tw` prop, but some things are missing (see Satori docs).
 *
 * @todo add support for custom bg image via post.data.ogImage
 * @todo add support for resizing bg image before using it (sharp?)
 * @todo add support for custom template via setup.json
 */

import fs from 'node:fs';
import path from 'node:path';
import crypto from 'node:crypto';
import satori, { type SatoriOptions } from 'satori';
import { html } from 'satori-html';
import { Resvg } from '@resvg/resvg-js';
import setup from '@data/setup.json' with { type: 'json' };

type OgFormat = 'png' | 'jpeg' | 'webp';

/**
 * Props with defaults
 */
interface Props extends PostProp<'blog'> {
  /**
   * Width of the generated image in pixels (default: 1200)
   */
  width?: number;
  /**
   * Height of the generated image in pixels (default: 630; 675 for return type `twitter`)
   */
  height?: number;
  /**
   * Alt text for the generated image
   * (default: post.data.title)
   */
  alt?: string;
  /**
   * Output format - what to return from this component:
   *
   * - `og`: a full `<meta property="og:image" content="...">` tag with subtags (default)
   * - `path`: the path to the generated image from site root
   * - `tag`: an <img> tag
   * - `twitter`: a full `<meta name="twitter:image" content="...">` tag with subtags
   * - `url`: the full URL to the image (for use in meta tags with absolute URLs)
   */
  return?: 'og' | 'path' | 'tag' | 'twitter' | 'url';
  format?: OgFormat;
}
const {
  post,
  width,
  height,
  return: returnType = 'og',
  alt = post.data.title,
  format = 'jpeg',
} = Astro.props;

// conditional defaults
const finalWidth = width ?? 1200;
const finalHeight = height ?? (returnType === 'twitter' ? 675 : 630);

/**
 * Our font for Satori
 *
 * @todo find a way to soft code them into the component so the global config
 *       can be used to set up fonts
 */
const ChangaPath =
  './node_modules/@fontsource/changa-one/files/changa-one-latin-400-normal.woff';
const Exo2Path =
  './node_modules/@fontsource/exo-2/files/exo-2-latin-400-normal.woff'; // non-variable font

/**
 * Read font data once at module load.
 * @todo is it once though?
 */
const ChangaData = fs.readFileSync(ChangaPath);
const Exo2Data = fs.readFileSync(Exo2Path);

// Cache directory: keep it out of git, easy to persist in CI.
const CACHE_DIR = path.join(process.cwd(), 'public', 'og_image');

/**
 * Build Satori options for a given size.
 * @param {number} width
 * @param {number} height
 * @returns {SatoriOptions}
 */
function buildOgOptions(width: number, height: number): SatoriOptions {
  return {
    //debug: true,
    fonts: [
      { data: ChangaData, name: 'Changa', style: 'normal', weight: 400 },
      { data: Exo2Data, name: 'Exo 2', style: 'normal', weight: 300 },
    ],
    height,
    width,
  };
}

/**
 * Ensure cache directory exists.
 * @returns {void}
 */
function ensureCacheDir(): void {
  try {
    if (!fs.existsSync(CACHE_DIR)) fs.mkdirSync(CACHE_DIR, { recursive: true });
  } catch (e) {
    console.error('[og] ensureCacheDir failed', e);
    throw e;
  }
}

type OgImageResult = {
  src: string; // web path
  width: number;
  height: number;
  format: OgFormat;
  mime: 'image/png' | 'image/jpeg' | 'image/webp';
};

function extFor(format: OgFormat) {
  return format === 'jpeg' ? 'jpg' : format; // jpg for file system
}

function mimeFor(format: OgFormat): OgImageResult['mime'] {
  switch (format) {
    case 'jpeg':
      return 'image/jpeg';
    case 'webp':
      return 'image/webp';
    default:
      return 'image/png';
  }
}

async function optimizeWithSharp(
  inputPngBuffer: Uint8Array,
  format: OgFormat,
): Promise<Buffer> {
  const sharp = (await import('sharp')).default;

  const image = sharp(inputPngBuffer);

  switch (format) {
    case 'png':
      // Smaller PNGs: palette reduces to 8-bit where possible
      return image
        .png({ compressionLevel: 9, effort: 10, palette: true })
        .toBuffer();

    case 'jpeg':
      // Great default for photo backgrounds
      return image.jpeg({ quality: 82, mozjpeg: true }).toBuffer();

    case 'webp':
      // Often even smaller than JPEG; OG/Twitter generally fine, but YMMV on some scrapers
      return image.webp({ quality: 80 }).toBuffer();
  }
}

/**
 * Create a short, deterministic content hash.
 * Includes title + pubDate + dimensions to separate caches by size.
 * @param {string} title
 * @param {Date} pubDate
 * @param {number} width
 * @param {number} height
 * @returns {string}
 */
function generateContentHash(
  title: string,
  pubDate: Date | undefined,
  width: number,
  height: number,
  format: OgFormat,
): string {
  const base = `${title}-${width}x${height}-${format}`;
  const content = pubDate ? `${base}-${pubDate.toISOString()}` : base; // <-- DEFAULT-IMAGE-HOOK (no date)
  return crypto.createHash('sha256').update(content).digest('hex').slice(0, 16);
}

/**
 * Lookup or render the PNG, then persist it.
 */
async function getCachedOrGeneratePng(
  title: string,
  pubDate: Date | undefined,
  postDateDisplay: string,
  width: number,
  height: number,
  format: OgFormat, // NEW
): Promise<OgImageResult> {
  ensureCacheDir();

  const contentHash = generateContentHash(
    title,
    pubDate,
    width,
    height,
    format,
  );
  const fileName = `${contentHash}.${extFor(format)}`;
  const fileFsPath = path.join(CACHE_DIR, fileName);
  const fileWebPath = `/og_image/${fileName}`;

  if (fs.existsSync(fileFsPath)) {
    console.log('[og] Using cache:', fileFsPath);
    return { src: fileWebPath, width, height, format, mime: mimeFor(format) };
  }

  console.log(
    `[og] Generating OG image: ${title} @ ${width}x${height} (${format})`,
  );
  let svg: string;
  try {
    svg = await satori(
      markup(title, postDateDisplay, width, height),
      buildOgOptions(width, height),
    );
  } catch (e) {
    console.error('[og] Satori render failed', e);
    throw e;
  }

  try {
    // 1) Render base PNG via Resvg
    const renderedPng = new Resvg(svg, { fitTo: { mode: 'original' } })
      .render()
      .asPng();

    // 2) Optimize/transcode via Sharp
    const optimized = await optimizeWithSharp(renderedPng, format);

    fs.writeFileSync(fileFsPath, optimized);
  } catch (e) {
    console.error('[og] Render/optimize/write failed', e);
    throw e;
  }

  return { src: fileWebPath, width, height, format, mime: mimeFor(format) };
}

/**
 * Build Satori markup for the OG image.
 *
 * @TODO implement with global template via setup.json for instance
 */
function markup(
  title: string,
  postDateDisplay: string,
  width: number,
  height: number,
) {
  const hasDate = postDateDisplay.trim().length > 0;
  const dateHtml = hasDate
    ? '<p tw="text-2xl">' + postDateDisplay + '</p>'
    : '';

  return html`
    <div
      style="display:contents;"
      tw="relative w-full h-full"
    >
      <img
        src="https://images.unsplash.com/photo-1759338069275-333580793462"
        width="${width}"
        height="${height}"
        style="position:absolute;top:0;left:0;width:100%;height:100%;
              object-fit:cover;object-position:center;"
      />
      <div
        style="font-family:'Exo 2',sans-serif;"
        tw="flex flex-col w-full h-full bg-[#282828]/60 text-[#999999]"
      >
        <div tw="flex flex-col flex-1 w-full p-10 leading-none">
          <h1
            style="font-family:'Changa',sans-serif;"
            tw="text-6xl leading-snug text-white"
          >
            ${title}
          </h1>
          <p tw="text-xl">by ${setup.author.name}</p>
        </div>
        <div
          tw="flex flex-0 items-center justify-between w-full p-10 border-t border-[#2bbc89] text-xl"
        >
          <p style="font-family:'Changa',sans-serif;">${setup.title}</p>
          ${dateHtml}
        </div>
      </div>
    </div>
  `;
}

// Drive generation with safe fallbacks:
// - title "unknown" when post.data missing
// - no dates in hash/markup when post.data missing
const isCollectionEntry =
  typeof post?.id === 'string' &&
  post.id.length > 0 &&
  typeof post?.collection === 'string' &&
  post.collection.length > 0;

const ogTitle = post.data?.title ?? 'unknown';

const pubDate = isCollectionEntry ? post.data?.date : undefined;

const rawDisplayDate = isCollectionEntry
  ? (post.data?.modified ?? post.data?.lastModified ?? post.data?.date)
  : undefined;

const displayDate =
  rawDisplayDate instanceof Date
    ? rawDisplayDate.toISOString().slice(0, 10)
    : typeof rawDisplayDate === 'string'
      ? rawDisplayDate
      : '';

const ogimage = await getCachedOrGeneratePng(
  ogTitle,
  pubDate,
  displayDate,
  finalWidth,
  finalHeight,
  format,
);
---

<>
  {
    (() => {
      const altText = alt ?? (post?.data?.title || 'unknown');
      const abs = new URL(ogimage.src, Astro.site).toString();

      return (
        <>
          {returnType === 'path' && ogimage.src}

          {returnType === 'url' && abs}

          {returnType === 'tag' && (
            <img
              src={ogimage.src}
              alt={altText}
              width={finalWidth}
              height={finalHeight}
            />
          )}

          {returnType === 'twitter' && (
            <>
              <meta
                name="twitter:image"
                content={abs}
              />
              <meta
                name="twitter:image:alt"
                content={altText}
              />
            </>
          )}

          {(returnType === 'og' ||
            !['path', 'url', 'tag', 'twitter'].includes(returnType)) && (
            <>
              <meta
                property="og:image"
                content={abs}
              />
              <meta
                property="og:image:type"
                content={ogimage.mime}
              />
              <meta
                property="og:image:width"
                content={finalWidth.toString()}
              />
              <meta
                property="og:image:height"
                content={finalHeight.toString()}
              />
              <meta
                property="og:image:alt"
                content={altText}
              />
            </>
          )}
        </>
      );
    })()
  }
</>
