---
// @todo refactor and comment
/**
 * Dynamic, cached OG-image generation for blog posts.
 *
 * Pipeline:
 *  1) Build a small HTML tree (via satori-html) with a CSS background image.
 *  2) Render to SVG with Satori (fonts embedded once).
 *  3) Rasterize SVG to PNG with Resvg.
 *  4) (Transcode/optimize) PNG -> {jpeg|webp|png} via Sharp.
 *  5) Write to /public/og_image/<hash>.<ext> and return meta tags (or URL/path/tag).
 *
 * Key properties:
 *  - Content-addressed cache ensures stable filenames and no re-render when unchanged.
 *  - In-flight de-duplication prevents duplicate expensive work under concurrent requests.
 *  - Background images are pre-sized to the final output to avoid memory spikes.
 *  - Tailwind in Satori: always set an explicit text size when using leading-* utilities.
 *
 * Route: /blog/[year]/[slug]/og.png (used as a component inside <head>)
 *
 * @see https://github.com/vercel/satori
 * @see https://og-playground.vercel.app/
 * @see https://github.com/yisibl/resvg-js
 */

import fs from 'node:fs';
import path from 'node:path';
import crypto from 'node:crypto';
import satori, { type SatoriOptions } from 'satori';
import { html } from 'satori-html';
import { Resvg } from '@resvg/resvg-js';
import setup from '@data/setup.json' with { type: 'json' };
import { formatDisplayDate } from '@utils/datetime';
import { resolveImageKey } from '@utils/opengraph.ts';
import type { ResolveImageKeyOptions } from '@utils/opengraph';
import { createLogger, type Logger } from '@utils/logger';

const TEMPLATE_VERSION = 1; // bump to invalidate everything after template/style changes

const log: Logger = createLogger({ slug: 'OpenGraphImage' });

type OgFormat = 'png' | 'jpeg' | 'webp';

export interface Props extends PostProp<'blog'> {
  /** Width of the generated image in px (default: 1200) */
  width?: number;
  /** Height of the generated image in px (default: 630; 675 for return 'twitter') */
  height?: number;
  /** Alt text for the generated image (default: post.data.title) */
  alt?: string;
  /**
   * What to return:
   * - 'og':      full set of OG <meta> tags (default)
   * - 'twitter': Twitter <meta> tags
   * - 'path':    web path from site root (/og_image/abc.jpg)
   * - 'url':     absolute URL
   * - 'tag':     <img> tag
   */
  return?: 'og' | 'path' | 'tag' | 'twitter' | 'url';
  /** Output image format */
  format?: OgFormat;
}

const {
  post,
  width,
  height,
  return: returnType = 'og',
  alt = post.data.title,
  format = 'jpeg',
} = Astro.props as Props;

function toInt(n: unknown, fallback: number): number {
  const v = Number(n);
  return Number.isFinite(v) ? Math.round(v) : fallback;
}

function assertDimensions(
  w: number,
  h: number,
  log: Logger,
  minW = 120,
  minH = 120,
  maxW = 4096,
  maxH = 4096,
): void {
  if (w < minW || h < minH || w > maxW || h > maxH) {
    log.warn(
      { w, h, minW, minH, maxW, maxH },
      'Requested OG size outside recommended bounds; proceeding anyway',
    );
  }
}

// keep exact defaults, no clamping
const requestedWidth = toInt(width, 1200);
const requestedHeight = toInt(
  height ?? (returnType === 'twitter' ? 675 : 630),
  630,
);

// these are the exact canvas dimensions used throughout
const finalWidth = requestedWidth;
const finalHeight = requestedHeight;

// just warn (do not modify)
assertDimensions(finalWidth, finalHeight, log);

/** Central config for easy tuning */
const CONFIG = {
  cacheDir: path.join(process.cwd(), 'public', 'og_image'),
  sharp: {
    limitInputPixels: 64_000_000, // ~64MP guard
    cache: { items: 32, files: 0, memory: 32 },
    concurrency: 1,
    jpegQuality: 80,
    webpQuality: 80,
    pngCompression: 9 as 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,
    pngEffort: 10 as 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10,
  },
} as const;

/** Fonts (read once at module load) */
const ChangaPath =
  './node_modules/@fontsource/changa-one/files/changa-one-latin-400-normal.woff';
const Exo2Path =
  './node_modules/@fontsource/exo-2/files/exo-2-latin-400-normal.woff';

let fontLoadError = false;
const ChangaData = safeReadFile(ChangaPath);
const Exo2Data = safeReadFile(Exo2Path);
if (!ChangaData || !Exo2Data) {
  fontLoadError = true;
  log.error('Failed to load one or more fonts. OG image rendering may fail.');
}

/** Cache de-duplication for concurrent renders */
const inFlight = new Map<string, Promise<OgImageResult>>();

/** Remote key detector */
const REMOTE_IMAGE_REGEX = /^https?:\/\//i;

// ---------- Types ----------

type OgImageResult = {
  src: string; // web path (e.g., /og_image/abcd1234.jpg)
  width: number;
  height: number;
  format: OgFormat;
  mime: 'image/png' | 'image/jpeg' | 'image/webp';
};

// ---------- Helpers ----------

/**
 * Safe readFileSync returning Buffer | null with logging.
 */
function safeReadFile(filePath: string): Buffer | null {
  try {
    return fs.readFileSync(filePath);
  } catch (e) {
    log.error({ filePath, err: e }, 'safeReadFile failed');
    return null;
  }
}

/**
 * Ensure cache directory exists.
 */
function ensureCacheDir(): void {
  try {
    if (!fs.existsSync(CONFIG.cacheDir))
      fs.mkdirSync(CONFIG.cacheDir, { recursive: true });
  } catch (e) {
    log.error({ err: e, dir: CONFIG.cacheDir }, 'ensureCacheDir failed');
    throw e;
  }
}

/**
 * Build and memoize Satori options for a given size.
 */
const ogOptionsCache = new Map<string, SatoriOptions>();
function buildOgOptions(width: number, height: number): SatoriOptions {
  const key = `${width}x${height}`;
  const cached = ogOptionsCache.get(key);
  if (cached) return cached;

  const opts: SatoriOptions = {
    width,
    height,
    fonts: [
      { data: ChangaData!, name: 'Changa', style: 'normal', weight: 400 },
      { data: Exo2Data!, name: 'Exo 2', style: 'normal', weight: 300 },
    ],
    // debug: true,
  };
  ogOptionsCache.set(key, opts);
  return opts;
}

/**
 * In-flight de-duplication wrapper.
 */
function getOrCreate(
  key: string,
  factory: () => Promise<OgImageResult>,
): Promise<OgImageResult> {
  const existing = inFlight.get(key);
  if (existing) return existing;

  const p = (async () => {
    try {
      return await factory();
    } finally {
      inFlight.delete(key);
    }
  })();

  inFlight.set(key, p);
  return p;
}

/**
 * Prepare background image as data URL, pre-sized to the output (or pass through remote).
 *
 * Note: For remote URLs, Satori can fetch directly. Keeping remote URLs reduces memory
 * since we avoid embedding huge base64 buffers. For local files, resize via Sharp first.
 */
async function toBackgroundImageSrc(
  key: string,
  targetW: number,
  targetH: number,
): Promise<string | null> {
  if (!key) return null;

  const sharp = (await import('sharp')).default;
  sharp.cache(CONFIG.sharp.cache);
  sharp.concurrency(CONFIG.sharp.concurrency);

  // Remote: fetch then resize -> data URL
  if (REMOTE_IMAGE_REGEX.test(key)) {
    try {
      const ac = new AbortController();
      const t = setTimeout(() => ac.abort(), 10_000); // 10s guard
      const res = await fetch(key, { signal: ac.signal });
      clearTimeout(t);

      if (!res.ok) {
        log.warn(
          { url: key, status: res.status },
          'Remote background fetch failed',
        );
        return null;
      }

      const buf = Buffer.from(await res.arrayBuffer());
      const out = await sharp(buf)
        .resize({
          width: targetW,
          height: targetH,
          fit: 'cover',
          withoutEnlargement: true,
        })
        .jpeg({ quality: CONFIG.sharp.jpegQuality, mozjpeg: true })
        .toBuffer();

      return `data:image/jpeg;base64,${out.toString('base64')}`;
    } catch (err) {
      log.error({ url: key, err }, 'Remote background processing failed');
      return null;
    }
  }

  // Local file: read then resize -> data URL
  const relative = key.replace(/^\/+/, '');
  const filePath = path.join(process.cwd(), relative);
  if (!fs.existsSync(filePath)) {
    log.warn({ filePath }, 'Background image not found');
    return null;
  }

  try {
    const out = await sharp(filePath)
      .resize({
        width: targetW,
        height: targetH,
        fit: 'cover',
        withoutEnlargement: true,
      })
      .jpeg({ quality: CONFIG.sharp.jpegQuality, mozjpeg: true })
      .toBuffer();

    return `data:image/jpeg;base64,${out.toString('base64')}`;
  } catch (error) {
    log.error({ err: error, filePath }, 'Failed to prepare background image');
    return null;
  }
}

/**
 * Hash includes title, pubDate (if present), dimensions, format, and background key.
 * Any change yields a new filename.
 */
function generateContentHash(
  title: string,
  pubDate: Date | undefined,
  width: number,
  height: number,
  format: OgFormat,
  imageKey: string,
): string {
  const base = JSON.stringify({
    v: TEMPLATE_VERSION,
    title,
    width,
    height,
    format,
    imageKey,
    siteTitle: setup.title ?? '',
    author: setup.author?.name ?? '',
  });
  const content = pubDate ? `${base}-${pubDate.toISOString()}` : base;
  return crypto.createHash('sha256').update(content).digest('hex').slice(0, 16);
}

function extFor(format: OgFormat): 'png' | 'jpg' | 'webp' {
  return format === 'jpeg' ? 'jpg' : format;
}

function mimeFor(format: OgFormat): OgImageResult['mime'] {
  switch (format) {
    case 'jpeg':
      return 'image/jpeg';
    case 'webp':
      return 'image/webp';
    default:
      return 'image/png';
  }
}

/**
 * Transcode/optimize the rendered PNG into requested format with conservative memory.
 */
async function optimizeWithSharp(
  inputPngBuffer: Uint8Array,
  format: OgFormat,
): Promise<Buffer> {
  const sharp = (await import('sharp')).default;
  sharp.cache(CONFIG.sharp.cache);
  sharp.concurrency(CONFIG.sharp.concurrency);

  const image = sharp(inputPngBuffer, {
    limitInputPixels: CONFIG.sharp.limitInputPixels,
  });

  switch (format) {
    case 'png':
      return image
        .png({
          compressionLevel: CONFIG.sharp.pngCompression,
          effort: CONFIG.sharp.pngEffort,
          palette: true,
        })
        .toBuffer();
    case 'jpeg':
      return image
        .jpeg({ quality: CONFIG.sharp.jpegQuality, mozjpeg: true })
        .toBuffer();
    case 'webp':
      return image.webp({ quality: CONFIG.sharp.webpQuality }).toBuffer();
  }
}

/**
 * Satori markup â€” background via CSS on the outer container (no absolute positioning).
 * Tailwind notes: whenever using leading-*, also set text-* on the same node or inline line-height.
 */
function markup(
  title: string,
  postDateDisplay: string,
  width: number,
  height: number,
  backgroundSrc: string,
) {
  const hasDate = postDateDisplay.trim().length > 0;
  const dateHtml = hasDate ? postDateDisplay : '';

  function cssUrl(u: string): string {
    // Escape single quote, backslash, and line breaks
    return `url('${u.replace(/['\\\n\r]/g, m => (m === "'" ? "\\'" : '\\' + m))}')`;
  }

  const bgDecl = backgroundSrc
    ? `background-image:${cssUrl(backgroundSrc)};`
    : '';
  const containerStyle = `width:${width}px;height:${height}px;${bgDecl}background-size:cover;background-position:center;background-repeat:no-repeat;`;

  return html`
    <div
      style="${containerStyle}"
      tw="flex flex-col"
    >
      <div
        style="font-family:'Exo 2',sans-serif;"
        tw="flex flex-col w-full h-full bg-[#09090b]/40 text-white text-xl"
      >
        <div tw="flex flex-col flex-1 w-full p-10 text-xl">
          <h1
            style="font-family:'Changa';line-height:1"
            tw="text-6xl text-white p-0 m-0"
          >
            ${title}
          </h1>
          <p tw="p-0 m-0 text-xl">by ${setup.author.name}</p>
        </div>
        <div tw="flex items-center justify-between w-full p-10 text-xl">
          <p
            style="font-family:'Changa';line-height:1"
            tw="text-4xl"
          >
            ${setup.title}
          </p>
          <p
            tw="text-right text-xl"
            style="line-height:1"
          >
            ${dateHtml}
          </p>
        </div>
      </div>
    </div>
  `;
}

/**
 * Render (or reuse cached) OG image on disk and return its metadata.
 */
async function getCachedOrGeneratePng(
  title: string,
  pubDate: Date | undefined,
  postDateDisplay: string,
  width: number,
  height: number,
  format: OgFormat,
  backgroundSrc: string,
  imageKey: string,
): Promise<OgImageResult> {
  if (fontLoadError) {
    throw new Error('Font load failed earlier; aborting OG generation.');
  }

  ensureCacheDir();

  const contentHash = generateContentHash(
    title,
    pubDate,
    width,
    height,
    format,
    imageKey,
  );
  const fileName = `${contentHash}.${extFor(format)}`;
  const fileFsPath = path.join(CONFIG.cacheDir, fileName);
  const fileWebPath = `/og_image/${fileName}`;

  if (fs.existsSync(fileFsPath)) {
    log.debug({ fileFsPath }, 'Using cached OG image');
    return { format, height, mime: mimeFor(format), src: fileWebPath, width };
  }

  // De-duplicate concurrent work
  return getOrCreate(fileFsPath, async () => {
    log.info({ title, width, height, format }, 'Generating OG image');

    const endGen = log.timer('render');
    let svg: string;
    try {
      svg = await satori(
        markup(title, postDateDisplay, width, height, backgroundSrc),
        buildOgOptions(width, height),
      );
      endGen('satori');
    } catch (e) {
      endGen('satori failed');
      throw e;
    }

    const endPix = log.timer('pixels');
    try {
      const renderedPng = new Resvg(svg, { fitTo: { mode: 'original' } })
        .render()
        .asPng();
      const optimized = await optimizeWithSharp(renderedPng, format);
      const tmp = `${fileFsPath}.tmp-${process.pid}-${Date.now()}`;
      fs.writeFileSync(tmp, optimized);
      fs.renameSync(tmp, fileFsPath);
      log.debug(
        { fileFsPath, bytes: optimized.byteLength },
        'OG image written',
      );
      endPix('resvg+sharp');
    } catch (e) {
      endPix('resvg+sharp failed');
      try {
        if (fs.existsSync(fileFsPath)) fs.unlinkSync(fileFsPath);
      } catch {}
      log.error({ err: e }, 'Resvg/Sharp pipeline failed');
      throw e;
    }

    return { format, height, mime: mimeFor(format), src: fileWebPath, width };
  });
}

// ---------- Content-specific resolution ----------

const isCollectionEntry =
  typeof post?.id === 'string' &&
  post.id.length > 0 &&
  typeof post?.collection === 'string' &&
  post.collection.length > 0;

const ogTitle = post.data?.title ?? 'unknown';
const pubDate = isCollectionEntry ? post.data?.date : undefined;

const rawDisplayDate = isCollectionEntry
  ? (post.data?.modified ?? post.data?.lastModified ?? post.data?.date)
  : undefined;
const displayDate = formatDisplayDate(rawDisplayDate);

const defaultArticleImageKey = (setup.images?.default ?? '').trim();
const ogFallbackKey = (setup.images?.opengraph ?? '').trim();

/**
 * Resolve the cover image key for OG background.
 * With exactOptionalPropertyTypes enabled, omit defaultKey when undefined.
 */
function resolveCoverImageKey(): string {
  if (!isCollectionEntry) return '';

  type CoverField = { type?: unknown; src?: unknown };
  const rawCover = post?.data?.cover;
  const cover: CoverField =
    rawCover && typeof rawCover === 'object' ? (rawCover as CoverField) : {};
  const coverType = typeof cover.type === 'string' ? cover.type : 'image';

  const defaultKeyMaybe =
    (defaultArticleImageKey || ogFallbackKey || '').trim() || undefined;

  const opts: ResolveImageKeyOptions =
    defaultKeyMaybe !== undefined ? { defaultKey: defaultKeyMaybe } : {};

  const rawSrc = typeof cover.src === 'string' ? cover.src : undefined;
  return resolveImageKey(
    coverType !== 'video' ? rawSrc : undefined,
    post.id,
    post.collection,
    opts,
  );
}

const resolvedArticleImageKey = resolveCoverImageKey();

const backgroundImageCandidates = [
  resolvedArticleImageKey,
  defaultArticleImageKey,
  ogFallbackKey,
].filter((v, i, a): v is string => Boolean(v) && a.indexOf(v) === i);

let backgroundImageSrc = '';
let backgroundImageKey = backgroundImageCandidates[0] ?? 'none';

for (const candidate of backgroundImageCandidates) {
  const src = await toBackgroundImageSrc(candidate, finalWidth, finalHeight);
  if (src) {
    backgroundImageSrc = src;
    backgroundImageKey = candidate;
    break;
  }
}

if (!backgroundImageSrc) {
  log.warn(
    { candidates: backgroundImageCandidates },
    'No background resolved; using solid overlay only',
  );
  backgroundImageKey = 'none';
}

const ogimage = await getCachedOrGeneratePng(
  ogTitle,
  pubDate,
  displayDate,
  finalWidth,
  finalHeight,
  format,
  backgroundImageSrc,
  backgroundImageKey,
);
---

<>
  {
    (() => {
      const altText = alt ?? (post?.data?.title || 'unknown');
      const abs = Astro.site
        ? new URL(ogimage.src, Astro.site).toString()
        : ogimage.src;

      return (
        <>
          {returnType === 'path' && ogimage.src}

          {returnType === 'url' && abs}

          {returnType === 'tag' && (
            <img
              src={ogimage.src}
              alt={altText}
              width={finalWidth}
              height={finalHeight}
            />
          )}

          {returnType === 'twitter' && (
            <>
              <meta
                name="twitter:image"
                content={abs}
              />
              <meta
                name="twitter:image:alt"
                content={altText}
              />
            </>
          )}

          {(returnType === 'og' ||
            !['path', 'url', 'tag', 'twitter'].includes(returnType)) && (
            <>
              <meta
                property="og:image"
                content={abs}
              />
              <meta
                property="og:image:type"
                content={ogimage.mime}
              />
              <meta
                property="og:image:width"
                content={finalWidth.toString()}
              />
              <meta
                property="og:image:height"
                content={finalHeight.toString()}
              />
              <meta
                property="og:image:alt"
                content={altText}
              />
            </>
          )}
        </>
      );
    })()
  }
</>
